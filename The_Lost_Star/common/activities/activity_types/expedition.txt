activity_expedition = {
	is_shown = {
		highest_held_title_tier > tier_barony
		is_landed = yes
		is_ai = no
	}
	
	can_start_showing_failures_only = {
		is_available_adult = yes
		can_do_expedition_trigger = yes
	}

	is_valid = {
		scope:host = {
			is_alive = yes
			is_imprisoned = no
			is_landed = yes 
			NOT = { is_incapable = yes }
		}
		NOT = { has_variable = expedition_invalidated }

#		Fix Note: change this once ruin buildings are in
#		trigger_if = {
#			limit = { exists = var:hunt_started }
#			exists = var:ruin_type
#		}

		# If no one shows up
		trigger_if = {
			limit = {
				is_current_phase_active = yes
			}
			has_attending_activity_guests = yes
		}
	}

	on_invalidated = {
		# Save scopes for flavor events
		scope:activity = {
			var:expedition_invalidated_flavor ?= { save_scope_as = invalidated_flavor }
			var:expedition_invalidated_culprit ?= { save_scope_as = invalidated_culprit }
			every_attending_character = {
				limit = {
					is_ai = no
					is_alive = yes
					NOR = {
						this = scope:invalidated_culprit
						this = scope:activity.activity_host
					}
				}
				add_to_list = attendees
			}
			if = { # Wound
				limit = { var:expedition_invalidated ?= flag:wounded }
				save_scope_as = wounded_invalidation
				every_in_list = {
					list = attendees
					trigger_event = expedition.0086
				}
			}
			else_if = { # Death
				limit = { var:expedition_invalidated ?= flag:death }
				save_scope_as = death_invalidation
				every_in_list = {
					list = attendees
					trigger_event = expedition.0080
				}
			}
			else_if = { # Assassination Attempt
				limit = { var:expedition_invalidated ?= flag:assassination_attempt }
				save_scope_as = assassination_invalidation
				every_in_list = {
					list = attendees
					trigger_event = expedition.0083
				}
			}
			else_if = { # Abduction Attempt
				limit = { var:expedition_invalidated ?= flag:abduction_attempt }
				save_scope_as = abduction_attempt_invalidation
				every_in_list = {
					list = attendees
					trigger_event = expedition.0084
				}
			}
			else_if = { # Abduction
				limit = { var:expedition_invalidated ?= flag:abduction }
				save_scope_as = abduction_invalidation
				every_in_list = {
					list = attendees
					trigger_event = expedition.0085
				}
			}
			else_if = { # Host Imprisoned
				limit = {
					scope:host = { is_imprisoned = yes}
				}
				every_in_list = {
					list = attendees
					trigger_event = expedition.0082
				}
			}
			# Host becomes unlanded
			else_if = {
				limit = {
					scope:host = { is_landed = no }
				}
				scope:activity = {
					activity_type = { save_scope_as = activity_type }
				}
				every_in_list = {
					list = attendees
					limit = { NOT = { this = scope:host } }
					trigger_event = activity_system.0320
				}
			}
			else_if = {
				limit = {
					scope:host = { is_incapable = yes }
				}
				scope:activity = {
					activity_type = { save_scope_as = activity_type }
				}
				scope:host = {
					trigger_event = activity_system.0330
				}
				every_in_list = {
					list = attendees
					limit = { NOT = { this = scope:host } }
					trigger_event = activity_system.0331
				}
			}
			else_if = { # No one shows up
				limit = {
					has_attending_activity_guests = no
				}
				scope:activity = {
					activity_type = { save_scope_as = activity_type }
					activity_location = { save_scope_as = location }
				}
				scope:host = { trigger_event = activity_system.0100 }
			}

			#Fix Note: this isnt used right now, but will be in future
			expedition_remove_variables_effect = yes
		}
	}

	on_host_death = {
		scope:activity = {
			save_scope_as = death_invalidation
		}
		scope:host = {
			save_scope_as = invalidated_flavor
			player_heir ?= {
				save_scope_as = heir
				add_character_flag = {
					flag = expedition_heir
					weeks = 1
				}
				trigger_event = { id = expedition.0080 days = 1 }
			}
		}
	}

	province_filter = realm

	ai_province_filter = domain

	is_location_valid = {
	}

	province_score = {
		add = 10
	}

	max_province_icons = 5

	###################
	# OPTIONS
	###################

	special_option_category = special_type

	options = {

		#Expedition types
		special_type = {
			# Generic Expedition.
			## Normal exploration expedition
			expedition_type_generic = {
				default = yes

				ai_will_do = {
					value = 50
					if = {
						limit = {
							OR = {
								has_trait = gregarious
								has_trait = arrogant
								has_trait = arbitrary
								has_trait = brave
								has_trait = just
							}
						}
						add = 50
					}
					if = {
						limit = {
							OR = {
								has_trait = shy
								has_trait = humble
								has_trait = callous
								has_trait = sadistic
							}
						}
						subtract = 50
					}
				}
			}
			# Raid Expedition.
			## Expedition into a more hostile location
			expedition_type_raid = {
				ai_will_do = {
					value = 50
					if = {
						limit = {
							OR = {
								has_trait = gregarious
								has_trait = arrogant
								has_trait = arbitrary
								has_trait = brave
								has_trait = just
							}
						}
						add = 50
					}
					if = {
						limit = {
							OR = {
								has_trait = shy
								has_trait = humble
								has_trait = callous
								has_trait = sadistic
							}
						}
						subtract = 50
					}
				}
			}
		}

	}

	###################
	# PHASES
	###################

	# Active phases of of an activity, each activity has at least one active phase, each must be uniquely named
	phases = {
		expedition_phase_excavation = {
			is_predefined = yes

			# Default to 1, how many times this phase can be picked as a unique phase, within one province
			# Only relevant if `is_predefined = no`
			# number_of_picks = script_value

			order = 1

			location_source = pickable

			is_shown = { always = yes }

			# Is this phase valid to pick for the activity
			# root = character trying to host this activity
			# scope:province = location to host the phase in
			# scope:special_option = flag of the selected special option, not set if activity has no special option category
			#can_pick = {
			#	<triggers>
			#}


			is_valid = {

			}

			# Run when this phase is set as the current but not active phase
			# root = character in this phase
			# scope:activity = the activity
			# scope:host = host of the activity
			#on_enter_phase = {
			#	<effects>
			#}

			# Run when this phase is set as to be active
			# root = character in this phase
			# scope:activity = the activity
			# scope:host = host of the activity
			on_phase_active = { # Fires for every attendee
				if = {
					limit = { this = scope:host }
					scope:activity = { progress_activity_phase_after = { weeks = 10 } }
					scope:activity = {
						every_attending_character = {
							limit = { is_ai = no }
							trigger_event = {
								on_action = expedition_random_pulse
								days = 7
							}
							trigger_event = {
								on_action = expedition_random_pulse
								days = 14
							}
						}
					}
				}
			}

			# Run when this phase ends
			# root = character in this phase
			# scope:activity = the activity
			# scope:host = host of the activity
			on_end = {

			}

			# Run when when the active phase's monthly pulses with this phase
			# root = character in this phase
			# scope:activity = the activity
			# scope:host = host of the activity
			#on_monthly_pulse = {
			#	<effects>
			#}

			# Run when when the active phase's weekly pulses with this phase.
			# Use if extra time dilation is necessary. 
			# root = character in this phase
			# scope:activity = the activity
			# scope:host = host of the activity
			#on_weekly_pulse = {
			#	<effects>
			#}

			# Run if this phase is invalidated by its is_valid trigger 
			# root = character in this phase
			# scope:activity = the activity
			# scope:host = host of the activity
			# scope:province = current phase location
			#on_invalidated = {
			#	<effects>
			#}

			# Cost for this phase being planned
			# root = character trying to host this activity
			# scope:province = location this phase would be at
			# scope:previous_province = either the location of the phase that preceeds this one, or the player capital if this is the first/only phase
			# scope:special_option = flag of the selected special option, not set if activity has no special option category
			#cost = {
			#	gold = {}
			#	piety = {}
			#	prestige = {}
			#	renown = {}
			#}
		}
	}

	# How many phases can be picked by the player in this activity, defaults to 0.
	# (All phases with 'is_predefined = yes' are not counted towards this number).
	# Requires the DLC feature to be able to create an activity that has multiple phases
	# root = character trying to host this activity
	#num_pickable_phases = 0

	# How many phases can be picked in this activity per province location
	# Defaults to `num_pickable_phases`
	# root = character trying to host this activity
	#max_pickable_phases_per_province = num_pickable_phases

	# How many days this activity will wait before starting the active part of its first phase on top of the estimated
	# travel arrival date of the Host.
	#
	# Defaults to 0
	#
	# root = character trying to host this activity
	wait_time_before_start = { days = 7 }

	# How many days this activity will delay the start date, to allow invited
	# guests to arrive.  Looks at rough estimated invited guests estimated travel time,
	# and the default activity start date (host arrival + wait_time_before_start).
	# This is added during planning of the activity.
	# (Does not apply to required special guests, we delay as much as needed for them)
	#
	# Defaults to 0 days, so either define this and/or `wait_time_before_start` to give
	# people time to arrive to your party.
	#
	# root = character trying to host this activity
	max_guest_arrival_delay_time = { months = 2 }

	# How much can a player (not AI) deviate from the default path via extra waypoints.
	# Expressed as multiplier of the total time duration of the default path. (path without waypoints)
	# eg: 2.0 = you can add waypoints resulting in a path with a duration up to twice as long as the default path.
	#
	# Default is defined in MAX_ROUTE_DEVIATION_MULTIPLIER_DEFAULT
	max_route_deviation_mult = 2.0

	# Cooldown between this activity being hosted again
	# root = character trying to host this activity
	cooldown = {
		years = 1
	}

	# Is this activity a grand activity or not, defaults to no
	is_grand_activity = no

	# Do all phases in this activity take place in the same province, defaults to yes
	is_single_location = yes

	# The planner type - how the activity planner shows things.
	# Available types:
	#  province - (Default) show the province name (province name)
	#  holder - show holder information (opinion, character pin)
	planner_type = province

	### Brief: ai_will_do (scripted value int32)
	# How likely is the AI to elect to host this activity if valid? This value 
	# must also exceed define ACTIVITY_SCORE_THRESHOLD to be eligible. Once all
	# activity types has been evaluated for hosting, the highest scoring
	# activity will be selected as the hosting candidate. This value will then
	# be used as a percent chance to be hosted, such that 0 will never be 
	# hosted and 100 will always be hosted. 
	#
	# Root = character evaluating the activity
	ai_will_do = {
		value = 10
	}

	### Brief: ai_check_interval ( int32)
	# How often will the AI check if it can host this particular activity in 
	# months? 
	ai_check_interval = 1
	
	### Brief: ai_will_select_province (scripted value int32)
	# How does the AI rate this province for the activity? All candidates are 
	# selected using weighted random based on these values.
	#
	# Root = province being evaluated
	# scope:host = host of the activity
	# scope:special_option = flag of the selected special option, not set if activity has no special option category
	# scope:score = the province_score calculated for this province
	ai_will_select_province = {

	}

	### Brief: ai_select_num_provinces (scripted value int32)
	# How many provinces does the AI attempt to select? This is only used for multi-location activities.
	#
	# Root = host of the activity
	ai_select_num_provinces = {

	}

	# Cost for this activity being planned at all
	# root = character trying to host this activity
	#
	# The following scopes are only passed in when available (not when calculating min-cost for example)
	# scope:special_option = flag of the selected special option, not set if activity has no special option category
	# scope:province = in a single location activity the selected location
	# list provinces = in a multi location activity list of all selected locations
	cost = {
		gold = {
			add = { # Base cost, scaled by era
				value = expedition_activity_base_cost
				multiply = activity_cost_scale_by_era
			}
		}
		piety = {}
		prestige = {}
		renown = {}
	}

	# Predicted average cost for this activity if you plan one
	# Used to show a rough minimum or expected cost at all to plan this
	# 
	# root = character trying to host this activity
	ui_predicted_cost = {
		gold = {
			add = { # Base cost, scaled by era
				value = expedition_activity_base_cost
				multiply = activity_cost_scale_by_era
			}
		}
		piety = {}
		prestige = {}
		renown = {}
	}

	# How many guests can attend this activity, be very careful if you raise this value too high it will cause performance impacts
	# due to too many people travelling to activities and too many possible intent targets
	max_guests = 10

	# Is it allowed to start the activity with no guest invitations? This also implies
	# whether or not an activity will allow having zero attending guests. 
	# Default is no
	allow_zero_guest_invites = yes

	# What guest invite rules this activity shows
	# All rules to pick from
	# Left value is priority with which to invite them, lower his higher prio, priority must be >= 1
	guest_invite_rules = {
		rules = {
			2 = activity_invite_rule_rivals
			2 = activity_invite_rule_lovers
			3 = activity_invite_rule_close_family
			3 = activity_invite_rule_extended_family
			3 = activity_invite_rule_knights
			4 = activity_invite_rule_guests
			
			# MP 
			6 = activity_invite_mp
		}

		# Same as above but these rules are enabled by default for the player
		# They will be appended to the main rules and insert their priority, so they should not be in the above list
		defaults = {
			3 = activity_invite_rule_liege
			3 = activity_invite_rule_vassals
			1 = activity_invite_rule_friends
			2 = activity_invite_rule_glory_hounds
			1 = activity_invite_rule_antiquarian
			4 = activity_invite_rule_courtiers
			4 = activity_invite_rule_fellow_vassals
		}
	}

	# Can this character be a guest at this specific activity type, checked in addition to the base
	# can_be_activity_guest scripted rule, so don't need to check what that also checks for basic requirements
	# root = character
	# scope:host = the activity host
	# scope:special_option = flag of the selected special option, not set if activity has no special option category
	can_be_activity_guest = {
		is_adult = yes
		NOT = { has_trait = incapable }
		can_do_expedition_trigger = yes
		in_diplomatic_range = scope:host
	}

	### Brief: guest_subsets ( integer flag list )
	# List of subsets to define for the guests attending the activity. These 
	# will create subsets of guests that can be referenced per activity phase
	# on the defined key. 
	#guest_subsets = {
	#	guest_subset_1 guest_subset_two
	#}

#	# Special guests that can be appointed from the invite list and then specifically referenced in script
#	# An activity will wait for them to arrive before it begins, if a required guest declines or dies then the activity
#	# invalidates, if they are not required then it just continues without them
#	special_guests = {
#		# Special guest names are localized via their <key>. The localization key for the name shown to the host is "<key>_for_host".
#		<key> = {
#			# Is this special guest slot shown / available
#			# root = host
#			# scope:special_option = flag of the selected special option, not set if activity has no special option category
#			is_shown = {
#				<triggers>
#			}
#
#			# Is this guest required to be set at the start of the activity? Defaults to no. (example of required guest: bride in a wedding)
#			# If they decline, the activity invalidates automatically. (death does not invalidate, handle that in Activity `is_valid`)
#			is_required = yes/no
#
#			# Select a specific character to be filled as the special guest, if not set then they can be manually selected from any guest
#			# Pick them by doing save_scope_as = character
#			# root = host
#			# scope:special_option = flag of the selected special option, not set if activity has no special option category
#			# scope:<special_guest_key> = for every special guest type defined, will be the picked character if set or not be provided
#			# scope:special_guests = list of special guest characters
#			# if there is no selected guest. Allows you to check triggers based on another special guest, eg: can two people
#			# get married in a wedding
#			select_character = {
#				<interface effects>
#			}
#
#			# Is a character valid as this special guest role, if you have already filtered them out in the build_characters you don't need
#			# to double up checks here as well for example.
#			# root = character
#			# scope:host = the activity host
#			# scope:special_option = flag of the selected special option, not set if activity has no special option category
#			# scope:<special_guest_key> = for every special guest type defined, will be the picked character if set or not be provided
#			# scope:special_guests = list of special guest characters
#			# if there is no selected guest. Allows you to check triggers based on another special guest, eg: can two people
#			# get married in a wedding
#			can_pick = {
#				<triggers>
#			}
#
#			### Brief: ai_will_do (scripted value int32)
#			# How likely is the AI to pick a character for this special guest slot if they are valid?
#			# Characters will be selected using weighted random.
#			#
#			# Root = character picking the option
#			ai_will_do = {
#				value = 10
#			}
#
#			# Effect run when the special guest gets sent the invitation (before accepting the invitation)
#			# This effect is also shown in the interface.
#			# root = character
#			# scope:host = the activity host
#			# scope:special_option = flag of the selected special option, not set if activity has no special option category
#			# scope:<special_guest_key> = for every special guest type defined, will be the picked character if set or not be provided
#			# scope:special_guests = list of special guest characters
#			on_invite = {
#			}
#		}
#	}

#	### Brief: locales ( optional array )
#	# List of locale slots that can be found for the activity. 
#	locales = {
#
#		### Brief: <key> ( database key )
#		# Single slot with locales
#		<key> = {
#
#			### Brief: is_available ( trigger )
#			# Is this slot available? If not defined it will default to true.
#			# Use to add optional locale slots. 
#			#
#			# Supported scopes:
#			#		root ( Activity )
#			#			The activity being hosted
#			#		scope:host  ( Character )
#			#			Character hosting the activity
#			#		scope:activity ( Activity ) 
#			#			The activity being hosted
#			is_available = {
#
#			}
#		
#			### Brief: locales ( database key array )
#			# What locales shall be available in this activity type between 
#			# active phases?
#			locales = {
#				tavern church blacksmith
#			}
#		}
#	}
	### Brief: locale_cooldown - duration
	# How many days are all locales invalid to enter, after entering one
	#
	# Supported scopes:
	#		root ( Character )
	#			Character that visited the locale
	#		scope:host  ( Character )
	#			Character hosting the activity
	#		scope:activity ( Activity )
	#			The activity itself
	locale_cooldown = { days = 7 }

	### Brief auto_select_locale_cooldown - duration
	# When should a player auto-visit a locale?
	# Set whenever a locale is visited, or when a player arrives at the activity location.
	# If not defined, a player does not auto-visit locales.
	#
	# Supported scopes:
	#		root ( Character )
	#			Character in the activity
	#		scope:host  ( Character )
	#			Character hosting the activity
	#		scope:activity ( Activity )
	#			The activity itself
	auto_select_locale_cooldown = { days = 14 }

	### Brief early_locale_opening_duration - duration
	# From what time are locales visitable before the start of the activity phases.
	# (setting it to 14 days will open the locales 14 days before the first phase' active state starts)
	# Not defining it will open the locales from the creation of the activity.
	#
	# Supported scopes:
	#		host  ( Character )
	#			Character hosting the activity
	#		scope:activity ( Activity )
	#			The activity itself
	early_locale_opening_duration = { days = 14 }

	# Anyone can choose to attend this activity if they meet its requirements
	# When planning an open invite activity only your court will specifically be invited
	open_invite = yes

	# List of valid intents for the host (default should be in the `intents` list too)
	host_intents = {
		intents = { reduce_stress_intent murder_attendee_intent woo_attendee_intent befriend_attendee_intent }
		# Default intent needs to be always valid
		default = reduce_stress_intent
		# Optional list of intents to try to default to for the player
		player_defaults = { reduce_stress_intent befriend_attendee_intent murder_attendee_intent }
	}

	# List of valid intents for the guests (default should be in the `intents` list too)
	guest_intents = {
		intents = { reduce_stress_intent murder_attendee_intent woo_attendee_intent befriend_attendee_intent }
		# Default intent needs to be always valid
		default = reduce_stress_intent
		# Optional list of intents to try to default to for the player
		player_defaults = { befriend_attendee_intent }
	}

	# Chance for a guest to accept an invitation to join this activity
	# root = character being invited
	# scope:host = host of the activity
	# scope:minimal_travel_time = the estimated "direct line" travel time for the guest to arrive in days
	# scope:activity_start_diff_days = how many days from the activity start date the guest is estimated to arrive (negative = late)
	# scope:<special_guest_key> = for every special guest type defined, will be the picked character if set or not be provided
	# scope:<option_category_key> = for every option category defined, will have a the flag of the selected option
	# scope:special_guests = list of special guest characters
	guest_join_chance = {
		base = 10

		modifier = {
			add = 10
		}
	}

#	# Effects run when a character enters a travel state
#	# root = character in this phase
#	# scope:activity = the activity
#	# scope:host = host of the activity
#	on_enter_travel_state = {
#		<effects>
#	}
#
#	# Effects run when a character enters a passive state after travel
#	# root = character in this phase
#	# scope:activity = the activity
#	# scope:host = host of the activity
#	on_enter_passive_state = {
#		<effects>
#	}
#
#	# Effects run when entering an active phase of the activity
#	# root = character in this phase
#	# scope:activity = the activity
#	# scope:host = host of the activity
#	on_enter_active_state = {
#		<effects>
#	}
#
#	# Effects run when a character leaves the travel state
#	# root = character in this phase
#	# scope:activity = the activity
#	# scope:host = host of the activity
#	on_leave_travel_state = {
#		<effects>
#	}
#
#	# Effects run when a character leaves the passive state
#	# root = character in this phase
#	# scope:activity = the activity
#	# scope:host = host of the activity
#	on_leave_passive_state = {
#		<effects>
#	}
#
#	# Effects run when a character leaves the active state
#	# root = character in this phase
#	# scope:activity = the activity
#	# scope:host = host of the activity
#	on_leave_active_state = {
#		<effects>
#	}
#
#	# Effects run during the activity event pulse for characters in the travel state
#	# root = character in this phase
#	# scope:activity = the activity
#	# scope:host = host of the activity
#	on_travel_state_pulse = {
#		<effects>
#	}
#
#	# Effects run during the activity event pulse for characters in the passive state
#	# root = character in this phase
#	# scope:activity = the activity
#	# scope:host = host of the activity
#	on_passive_state_pulse = {
#		<effects>
#	}
#
#	# Effects run during the activity event pulse for characters in the active state
#	# root = character in this phase
#	# scope:activity = the activity
#	# scope:host = host of the activity
#	on_active_state_pulse = {
#		<effects>
#	}
#
#	# Effects run when the activity is created
#	# root = the activity
#	# scope:activity = the activity
#	# scope:host = host of the activity
	on_start = {
		set_variable = {
			name = expedition_success_chance
			value = expedition_success_chance_value
		}
	}

#	# Effects run when the activity completes after its last phase
#	# Note: AI-only activities will not persist more than 1 day after this.
#	# root = character in this phase
#	# scope:activity = the activity
#	# scope:host = host of the activity
	on_complete = {
		if = {
			limit = { root = scope:host }
			scope:host = {
				save_scope_as = owner
				random_dummy_gender_effect = yes

				random_list = {
					10 = {
						create_artifact_weapon_effect = {
							OWNER = scope:owner
							CREATOR = scope:dummy_gender
							SET_WEAPON_TYPE = flag:no
						}
					}
					10 = {
						create_artifact_armor_effect = {
							OWNER = scope:owner
							CREATOR = scope:dummy_gender
							SET_ARMOR_TYPE = flag:no
						}
					}
					10 = {
						create_artifact_regalia_effect = {
							OWNER = scope:owner
							SMITH = scope:dummy_gender
						}
					}
					10 = {
						create_artifact_crown_effect = {
							OWNER = scope:owner
							SMITH = scope:dummy_gender
						}
					}
					10 = {
						create_artifact_brooch_effect = {
							OWNER = scope:owner
							SMITH = scope:dummy_gender
						}
					}
				}
			}
		}
	}

	# Plugin widgets to be added to the activity window if this type is viewed
	activity_window_widgets = {
		# Name = name of the plug in and its file path in gui/activity_window_widgets
		# Container = the widget in the main activity window to position this under
		expedition_success_chance = "activity_plugin_widgets_summary"
		artifact_rewards = "activity_plugin_widgets_conclusion"
	}

	# Plugin widgets to be added to the activity planner window if this type is viewed
	activity_planner_widgets = {
		# Name = name of the plug in widget and its file path in gui/activity_window_widgets/name.txt
		# Container = the widget in the main activity window to position this under
		name = "parent_container"
	}

	## The background for the activity is defined in event_backgrounds and looks up an entry with the same key as the activity

	# Map entity for the activity, multiple can be read in, first one is picked from order they are read in
	map_entity = {
		# root = the activity
		# scope:activity = the activity
		# scope:host = host of the activity
		reference = "building_mena_hunt_01_entity" # Entity name
	}

	#map_entity = "building_mena_hunt_01_entity" # Short hand for a single constant entity name

	# Background for the activity, multiple can be read in, first one is picked from order they are read in
	background = {
		# root = the activity
		# scope:activity = the activity
		# scope:host = host of the activity
		texture = "gfx/interface/illustrations/event_scenes/ep2_travel_bridge.dds"
		environment = "environment_travel_bridge"
		ambience = "event:/SFX/Events/Backgrounds/mountains_day"
		#music = "music_cue_track_name"
	}

	# Locale Background for the activity. Used exclusively by activities that 
	# use the locale window. Multiple can be read in, first one is picked from
	# order they are read in.
	locale_background = {
		# root = the activity
		# scope:activity = the activity
		# scope:host = host of the activity
		texture = "gfx/interface/illustrations/event_scenes/ep2_travel_farm.dds"
		environment = "environment_travel_farmlands"
		ambience = "event:/SFX/Events/Backgrounds/fields_farms_day"
		#music = "music_cue_track_name"
	}

	# Can read in multiple, they will be displayed left to right based on this order
	window_characters = {
		host = {
			camera = camera_event_center
			
			effect = {
				if = {
					limit = {
						OR = {
							scope:host.location = scope:activity.activity_location
							scope:host.location = { is_sea_province = yes }
						}
					}
					scope:host = {
						add_to_list = characters
					}
				}
			}
			scripted_animation = {
				animation = idle
			}
		}

		antiquarian = {
			camera = camera_event_center
			
			effect = {
				scope:host.court_position:antiquarian_court_position ?= {
						add_to_list = characters
				}
			}
			scripted_animation = {
				animation = thinking
			}
		}
	}

	# Select which court characters are added to the travel entourage of an invited / hosting character,
	# if that character would travel.
	# Weighted list is evaluated until all values are negative, or `max` is reached.
	travel_entourage_selection = {
		# List is all court characters.
		# root = character in the travel plan owners' court
		# scope:host = character hosting the activity
		# scope:owner = character owning the travel plan (host or guest)
		# scope:special_option = flag of the selected special option, not set if activity has no special option category
		weight = {
			value = 10
		}

		# Up to how many characters to select for a player
		max = 2
		
		# Up to how many characters to select for an AI
		ai_max = 2

		# What order, relative to the invite rule orders, should entourage members be invited in
		invite_rule_order = 3
	}
	
	# Description for hosting the activity, defaults to "<key>_province_desc"
	# root = the province
	# scope:host = character trying to host this activity
	# scope:special_option = flag of the selected special option, not set if activity has no special option category
	province_description = {
		first_valid = {
			desc = activity_invite_rule_antiquarian
		}
	}

	# Description for hosting the activity, defaults to "<key>_host_desc"
	# root = character trying to host this activity
	host_description = {
		first_valid = {
			desc = activity_invite_rule_glory_hounds
		}
	}

	guest_description = {
		first_valid = {
			desc = activity_invite_rule_glory_hounds
		}
	}

	# Description for concluding the activity, defaults to "<key>_conclusion_desc"
	# root = character in the conclusion screen
	# scope:activity = the activity
	# scope:host = host of the activity
	conclusion_description = {
		first_valid = {
			desc = activity_invite_rule_antiquarian
		}
	}
}
